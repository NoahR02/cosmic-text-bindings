#pragma once

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <cstdarg>
#include <cstddef>
#include <cstdint>
#include <cstdlib>
#include <ostream>
#include <new>
#include <cassert>


namespace cosmic_text {

enum class Shaping {
    /**
     * Basic shaping with no font fallback.
     *
     * This shaping strategy is very cheap, but it will not display complex
     * scripts properly nor try to find missing glyphs in your system fonts.
     *
     * You should use this strategy when you have complete control of the text
     * and the font you are displaying in your application.
     */
    Basic,
    /**
     * Advanced text shaping and font fallback.
     *
     * You will need to enable this strategy if the text contains a complex
     * script, the font used needs it, and/or multiple fonts in your system
     * may be needed to display all of the glyphs.
     */
    Advanced,
};

enum class Stretch {
    UltraCondensed,
    ExtraCondensed,
    Condensed,
    SemiCondensed,
    Normal,
    SemiExpanded,
    Expanded,
    ExtraExpanded,
    UltraExpanded,
};

enum class Style {
    /**
     * A face that is neither italic not obliqued.
     */
    Normal,
    /**
     * A form that is generally cursive in nature.
     */
    Italic,
    /**
     * A typically-sloped version of the regular face.
     */
    Oblique,
};

struct Buffer;

struct FontSystem;

struct SwashCache;

struct Color {
    uint32_t _0;
};

struct Family {
    enum class Tag {
        /**
         * The name of a font family of choice.
         *
         * This must be a *Typographic Family* (ID 16) or a *Family Name* (ID 1) in terms of TrueType.
         * Meaning you have to pass a family without any additional suffixes like _Bold_, _Italic_,
         * _Regular_, etc.
         *
         * Localized names are allowed.
         */
        Name,
        /**
         * Serif fonts represent the formal text style for a script.
         */
        Serif,
        /**
         * Glyphs in sans-serif fonts, as the term is used in CSS, are generally low contrast
         * and have stroke endings that are plain â€” without any flaring, cross stroke,
         * or other ornamentation.
         */
        SansSerif,
        /**
         * Glyphs in cursive fonts generally use a more informal script style,
         * and the result looks more like handwritten pen or brush writing than printed letterwork.
         */
        Cursive,
        /**
         * Fantasy fonts are primarily decorative or expressive fonts that
         * contain decorative or expressive representations of characters.
         */
        Fantasy,
        /**
         * The sole criterion of a monospace font is that all glyphs have the same fixed width.
         */
        Monospace,
    };

    struct Name_Body {
        const char *_0;
    };

    Tag tag;
    union {
        Name_Body name;
    };

    static Family Name(const char *const &_0) {
        Family result;
        ::new (&result.name._0) (const char*)(_0);
        result.tag = Tag::Name;
        return result;
    }

    bool IsName() const {
        return tag == Tag::Name;
    }

    const char*const & AsName() const {
        assert(IsName());
        return name._0;
    }

    static Family Serif() {
        Family result;
        result.tag = Tag::Serif;
        return result;
    }

    bool IsSerif() const {
        return tag == Tag::Serif;
    }

    static Family SansSerif() {
        Family result;
        result.tag = Tag::SansSerif;
        return result;
    }

    bool IsSansSerif() const {
        return tag == Tag::SansSerif;
    }

    static Family Cursive() {
        Family result;
        result.tag = Tag::Cursive;
        return result;
    }

    bool IsCursive() const {
        return tag == Tag::Cursive;
    }

    static Family Fantasy() {
        Family result;
        result.tag = Tag::Fantasy;
        return result;
    }

    bool IsFantasy() const {
        return tag == Tag::Fantasy;
    }

    static Family Monospace() {
        Family result;
        result.tag = Tag::Monospace;
        return result;
    }

    bool IsMonospace() const {
        return tag == Tag::Monospace;
    }
};

struct Weight {
    uint16_t _0;
};

/**
 * Flags that change rendering
 */
using CacheKeyFlags = uint32_t;
/**
 * Skew by 14 degrees to synthesize italic
 */
constexpr static const CacheKeyFlags CacheKeyFlags_FAKE_ITALIC = (uint32_t)1;

struct CacheMetrics {
    uint32_t font_size_bits;
    uint32_t line_height_bits;
};

struct Attrs {
    const Color *color_opt;
    Family family;
    Stretch stretch;
    Style style;
    Weight weight;
    size_t metadata;
    CacheKeyFlags cache_key_flags;
    const CacheMetrics *metrics_opt;
};

struct Metrics {
    /**
     * Font size in pixels
     */
    float font_size;
    /**
     * Line height in pixels
     */
    float line_height;
};

struct ColorRGBA {
    uint8_t r;
    uint8_t g;
    uint8_t b;
    uint8_t a;
};


extern "C" {

Attrs attrs_constructor();

Buffer *buffer_constructor(FontSystem **font_system, Metrics metrics);

void buffer_destructor(Buffer *buffer);

void buffer_draw(Buffer *buffer,
                 FontSystem *font_system,
                 SwashCache *swash_cache,
                 Color color,
                 void (*draw_fn)(int32_t, int32_t, uint32_t, uint32_t, Color));

void buffer_set_size(Buffer *buffer, FontSystem *font_system, float width, float height);

void buffer_set_text(Buffer *buffer,
                     FontSystem *font_system,
                     const char *text,
                     Attrs attrs,
                     Shaping shaping);

void buffer_shape_until_scroll(Buffer *buffer, FontSystem *font_system, bool prune);

uint8_t color_a(Color self);

ColorRGBA color_as_rgba(Color self);

uint8_t color_b(Color self);

uint8_t color_g(Color self);

uint8_t color_r(Color self);

Color color_rgba(uint8_t r, uint8_t g, uint8_t b, uint8_t a);

FontSystem *font_system_constructor();

void font_system_destructor(FontSystem *font_system);

Metrics metrics_constructor(float font_size, float line_height);

SwashCache *swash_cache_constructor();

void swash_cache_destructor(SwashCache *swash_cache);

} // extern "C"

} // namespace cosmic_text
